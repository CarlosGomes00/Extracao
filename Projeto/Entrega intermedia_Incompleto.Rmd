---
title: "**Trabalho Prático de Extração de Conhecimento de Dados Biológicos**"
date: "`r Sys.Date()`"
author: "Carlos Gomes (PG51681), Laís Carvalho (PG52536), Rita Nóbrega (PG46733)"
output: 
  html_document:
    toc: yes
    toc_depth: 2
    toc_float: yes
    theme: spacelab
    number_sections: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
---

```{=html}
<style>
  body {text-align:justify}
</style>
```

------------------------------------------------------------------------

# **Contextualização**

O conjunto de dados selecionados para este trabalho foram retirados de um estudo cohort com 672 amostras recolhidas através de biopsias a 562 pacientes com Leucemia Mielóide Aguda (LMA)[^1]. Com o objetivo de correlacionar a sensibilidade e resistência de grupos de pacientes com LMA a tratamentos já existentes com a ocorrência de mutações, foram realizadas anotações clínicas detalhadas, estudos genómicos e transcriptómicos (com a sequenciação do exoma (622 amostras) e do RNA (451 amostras)), assim como testes *ex vivo* de sensibilidade a compostos. Os dados e estudo original podem ser consultados através do Genomic Data Commons (GDC)[^2].

[^1]: (Tyner *et al*., 2018)

[^2]: <https://www.cbioportal.org/study/summary?id=aml_ohsu_2018>

Este trabalho tem como objetivo analisar os dados de expressão de pacientes com AML, comparando os seus dados transcriptómicos com amostras controlo (saudáveis), com vista a obter informações sobre genes diferencialmente expressos e enriquecidos, clusters de genes e/ou de amostras e que genes parecem ter maior importância no transcriptoma associado a AML.

Para começar com a análise, primeiro procedemos à **instalação** de algumas bibliotecas!

```{r Instalação dos packages}

# options(repos = c(CRAN = "https://cloud.r-project.org"))   Foi necessário definir um repositório no CRAN manualmente 

# install.packages("summarytools")

# install.packages("ggpubr")

# install.packages("tidyverse")

# install.packages("car", dependencies = "Imports")

# install.packages("carData")

#install.packages("readr")

```

Depois da sua instalação, fizemos o seu **carregamento**!

```{r Import dos packages}

library(summarytools)

library(car)

library(readr)

library(dplyr)

library(ggplot2)

library(ggpubr)

```

# **Datasets**

## *Transferência e leitura dos datastes*

Depois de importar as bibliotecas necessárias, começamos por **associar** os datasets presentes no repositório online [^3] a uma **variável**.

[^3]: <https://github.com/lais-carvalho/Trabalho-pratico/tree/main/Dados>

```{r Associação dos datasets a uma variável}

# RNA_cpm_url = "https://raw.githubusercontent.com/lais-carvalho/Trabalho-pratico/main/Dados/data_mrna_seq_cpm.txt" 
# Não está a fazer corretamente a leitura do ficheiro. Essa leitura só será possível utilizando o Git Large Files Storage, por isso para já utilizaremos uma cópia local

data_patient_url = "https://raw.githubusercontent.com/lais-carvalho/Trabalho-pratico/main/Dados/data_clinical_patient.txt"

data_sample_url = "https://raw.githubusercontent.com/lais-carvalho/Trabalho-pratico/main/Dados/data_clinical_sample.txt"

data_mutations_url = "https://raw.githubusercontent.com/lais-carvalho/Trabalho-pratico/main/Dados/data_mutations.txt"

```

De seguida, faz-se o **download** dos datasets e guardamos uma cópia local.

```{r Download dos Datasets}

# download.file(RNA_cpm_url, destfile="RNA_seq_cpm.txt")

download.file(data_patient_url, destfile="data_patient.txt") 

download.file(data_sample_url, destfile ="data_sample.txt")

download.file(data_mutations_url, destfile="data_mutations.txt")

```

E por fim a **leitura** desses ficheiros.

```{r Leitura dos ficheiros}

RNA_cpm = read.table("data_mrna_seq.txt", header = T, sep = '\t')

data_patient = read.table("data_patient.txt", header = T, sep = '\t')

data_sample = read_tsv("data_sample.txt", na = "", show_col_types = FALSE)

data_mutations = read.table("data_mutations.txt", header = T, sep = '\t')

```

## *Pré-processamento dos dados* {.tabset}

### RNA_cpm

O nosso dataset consiste em valores CPM (counts per million), uma medida usada para normalizar a expressão génica e facilitar a comparação entre amostras com nº total de reads diferentes.Então, quanto maior for o CPM, maior o na expressão de determinado gene numa determinada amostra (relativamente a outros genes na mesma amostra)

Antes desta conversão para CPM, os dados foram normalizados usando o 'Trimmed Mean of M caling' que serve para corrigir diferenças sistemáticas na composição das bibliotecas de RNA entre amostras (não é uma normalização dos dados em si, mas sim do tamanho da biblioteca). Esta normalização TMM já ajuda a reduzir a variabilidade técnica entre amostras.

Começámos por verificar alguns aspetos relativamente ao dataset.

```{r Verificar a estrutura dos dados}

class(RNA_cpm)

unlist(lapply(RNA_cpm,class)) 

dim(RNA_cpm)

colnames(RNA_cpm)

head(rownames(RNA_cpm))

```

Com o código acima é possível perceber:

-   **class(RNA_cpm)** -\> Classe do dataset, dataframe neste caso;

-   **unlist(lapply(RNA_cpm,class))** -\> Classe de cada coluna do dataframe

-   **dim(RNA_cpm)** -\> Dimensão do dataframe;

-   **colnames(RNA_cpm)** e **head(rownames(RNA_cpm))** -\> Verificar se o nome dos genes se está associado às linhas, e o nome das amostras às colunas.

Através do código utilizado em cima, verificamos que o dataset é um **dataframe** com uma dimensão de 22843 linhas e 453 colunas. As linhas estão representadas como genes enquanto que as colunas representam as amostras, no entanto uma das colunas serve como ID, o que corresponde a **22843 genes** e **452 amostras**. Além disso, foi possível verificar também que as linhas não estão associadas aos genes.

Percebemos também que existem genes duplicados.

```{r Remover duplicados}

which(duplicated(RNA_cpm[,1]))

RNA_cpm[which(duplicated(RNA_cpm[,1])),1]

which(RNA_cpm == 'BTBD8', arr.ind = T)

RNA_cpm[which(duplicated(RNA_cpm[,1])),1] = paste(RNA_cpm[which(duplicated(RNA_cpm[,1])),1], "_duplicado", sep = "")

which(duplicated(RNA_cpm[,1]))
      
RNA_cpm[13532, 1]

```

O código utilizado serviu para:

-   **(which(duplicated(RNA_cpm[,1])))** -\> Saber quantos genes têm o nome repetido;

-   **RNA_cpm[which(duplicated(RNA_cpm[,1])),1]** -\> Obter o nome dos genes duplicados;

-   **which(RNA_cpm == 'BTBD8', arr.ind = T)** -\> Confirmar se o nome está duplicado;

Nesta fase, e através de verificação manual, percebemos que o nome é de facto igual, no entanto os z-scores são diferentes.

Optamos então por adicionar "\_duplicado" para os distinguir.

-   \*\*RNA_cpm[which(duplicated(RNA_cpm[,1])),1] = paste(RNA_cpm[which(duplicated(RNA_cpm[,1])),1], "\_duplicado", sep = "")\*\* -\> Adiciona o "duplicado";

-   **which(duplicated(RNA_cpm[,1]))** -\> Retorna as posições das linhas duplicadas da primeira coluna;

-   **RNA_cpm[13532, 1]** -\> Retorna o valor na linha 13532 e coluna 1.

Assim, já é possível associar o nome dos genes às linhas, corretamente:

```{r Associar os nomes}

rownames(RNA_cpm) = RNA_cpm[, 1]

rownames(RNA_cpm)

```

-   **rownames(RNA_cpm) = RNA_cpm[, 1]** -\> Transformar os valores da primeira coluna, no nome das linhas;

-   **rownames(RNA_cpm)** -\> Verificar se não ocorreu nenhum erro no comando anterior;

De seguida, continuamos com o pré-processamento dos dados, verificando se existem valores omissos.

```{r Valores Omissos}
any(is.na(RNA_cpm))

RNA_cpm$Entrez_Gene_Id <- NULL

any(is.na(RNA_cpm))

```

-   **any(is.na(RNA_cpm))** -\> Ver se há missing values

-   **RNA_cpm\$Entrez_Gene_Id \<- NULL** -\> Eliminar a coluna com missing values

-   **any(is.na(RNA_cpm))** -\> Verificar outra vez se há missing values

Os valores omissos que existiam no dataframe estavam todos presentes na mesma coluna ('Entrez_Gene_Id"), por isso depois da sua eliminação, já não existem NAs.

Por último, decidimos verificar se existem genes com uma frequência de expressão zero, em acima de 90% das amostras:

```{r Retirar genes com expressão 0 frequente}

verificar_zero_frequente <- function(RNA_cpm) {
  genes_zero_frequente <- character(0)
  total_amostras <- ncol(RNA_cpm) - 1 
  for (i in 1:nrow(RNA_cpm)) {
    proporcao_zero <- sum(RNA_cpm[i, -1] == 0) / total_amostras
    if (proporcao_zero > 0.9) {
      genes_zero_frequente <- c(genes_zero_frequente, RNA_cpm[i, 1])
    }
  }
  return(genes_zero_frequente)
}

verificar_zero_frequente(RNA_cpm)

```

-   **verificar_zero_frequente \<- function(RNA_cpm) {...}** -\> Definir uma função;

-   **genes_zero_frequente \<- character(0)** -\> Inicia um vetor vazio para armazenar o nome dos genes;

-   **total_amostras \<- ncol(RNA_cpm) - 1** -\> Calcula o número total de amostras, com exceção da primeira coluna que corresponde ao nome dos genes;

-   **for (i in 1:nrow(RNA_cpm))** -\> Inicia um loop sobre cada linha;

-   **proporcao_zero \<- sum(RNA_cpm[i, -1] == 0) / total_amostras** -\> Calcula a proporção de valores 0 em cada linha, excluindo a primeira coluna;

-   **if (proporcao_zero \> 0.9)** -\> Verifica se a proporção dos valores é maior que 90%

-   **genes_zero_frequente \<- c(genes_zero_frequente, RNA_cpm[i, 1])** -\> Caso a condição anterior seja verdadeira, o nome do gene é adicionado ao vetor;

-   **return(genes_zero_frequente)** -\> Retorna o vetor contendo o nome dos genes com expressão 0 maior que 90%.

É possível observar que o código retorna o vetor vazio, o que significa que nenhum gene possui uma frequência de zeros superior a 90% em relação ao número total de amostras.


### Metadados {.tabset}

#### data_sample

Começámos por verificar alguns aspetos relativos ao dataset:

```{r Formato do dataset}
class(data_sample) 

data_sample = as.data.frame(data_sample)

class(data_sample)

str(data_sample)

```

-   **class(data_sample)** -\> Retorna a classe do dataset;

-   **data_sample = as.data.frame(data_sample)** -\> Converte o dataset todo num dataframe

-   **str(data_sample)** -\> Fornece uma descrição sobre a estrutura do dataframe

Havia vários formatos neste dataset, então decidimos estabelecer tudo como dataframe! Verificamos também que a classe de todas as colunas correspondem a um "character".

De seguida, para facilitar a nossa análise, colocamos o nome das colunas a corresponder aos outros datasets:

```{r Correspondência de colunas}

colnames(data_sample)

colnames(data_sample) = data_sample[4,]

colnames(data_sample)

```

-   **colnames(data_sample)** -\> Retorna a classe do dataset;

-   **colnames(data_sample) = data_sample[4,]** -\> Converte o dataset todo num dataframe

Agora, já podemos ver a dimensão do dataframe:

```{r Dimensão do dataframe}

dim(data_sample)

```

-   **dim(data_sample)** -\> Retorna um vetor com o número de linhas e o número de colunas no datafrmae;

O dataframe possui **676** linhas, correspondentes a **amostras** e **75** colunas correspondentes a **variáveis**.

As linhas do dataframe não estão associadas a nada, então, foi necessário associar cada linha ao ID de uma amostra:

```{r Associar as linhas}

row.names(data_sample) = data_sample$SAMPLE_ID

row.names(data_sample)  

row.names(data_sample) = gsub("-", ".", row.names(data_sample)) 

row.names(data_sample)

data_sample = data_sample[,-2]

```

-   **row.names(data_sample) = data_sample$SAMPLE_ID** -\> Associa os IDs das amostras com o nome das linhas do dataframe

-   **row.names(data_sample)** -\> Imprime o nome das linhas do dataframe

-   **row.names(data_sample) = gsub("-", ".", row.names(data_sample))** -\> Substitui todos os hifens nas linhas por pontos

-   **data_sample = data_sample[,-2]** -\> Remove a segunda coluna do dataframe


Para além de fazermos a associação, removemos ainda a segunda coluna do dataframe e ainda substituimos os hifens das linhas por pontos, de forma a padronizar a formatação dos nomes das linhas.

Depois, verificamos se existem duplicados no ID dos pacientes e no ID das amostras:

```{r Verificar duplicados}

any(duplicated(data_sample$PATIENT_ID))

any(duplicated(data_sample$SAMPLE_ID))

```

-   **any(duplicated(data_sample$PATIENT_ID))** -\> Verifica se existe algum valor duplicado na coluna "PATIENT_ID"

-   **any(duplicated(data_sample$SAMPLE_ID))** -\> Verifica se existe algum valor duplicado na coluna "SAMPLE_ID"

Percebemos que existem IDs dos pacientes duplicados, o que demonstra que várias amostras podem ter sido retiradas do mesmo paciente!

Além disso, não existem amostras duplicadas, tal como era previsto.

No entanto, nem todas as amostras foram utilizadas para o processo de análise de RNAseq. Existem duas variáveis nos metadados: RNA sequenced e RNA seq analysis.

Através da tabela de dados de RNA-seq, sabemos que 451 amostras foram analisadas.

```{r Filtração dos dados}

table(data_sample$RNA_SEQ_ANALYSIS)

pie(table(data_sample$RNA_SEQ_ANALYSIS), main = "RNA-Seq analysis?")

sample_data_rna = data_sample[data_sample$RNA_SEQ_ANALYSIS == 'Yes',]

dim(sample_data_rna)

sum(row.names(sample_data_rna) %in% colnames(RNA_cpm))

```

O código em cima serviu como filtro para perceber que dados de RNA-seq utilizar nas análises posteriores, garantindo que coincidem com os dados do dataset "RNA_cpm".




#### data_patient

Começámos por verificar alguns aspetos relativos ao dataset:

```{r Classes dos metadados}

class(data_patient)

dim(data_patient)

unlist(lapply(data_patient,class))

str(data_patient)

row.names(data_patient)

row.names(data_patient) <- data_patient$PATIENT_ID

row.names(data_patient)

data_patient <- data_patient[,-1]

```

O dataset é um dataframe com 562 linhas...

```{r Transformação das Variáveis}

str(data_patient)
data_patient[, c(1,2,4,5,7, 8, 9, 10, 11, 12, 13, 14, 18, 20, 21)] <- lapply(data_patient[, c(1,2,4,5,7, 8, 9, 10, 11, 12, 13, 14, 18, 20, 21)], as.factor)

```

Depois vamos ver se exitem NAs.

```{r Verificação de NAs}

sum(is.na(data_patient)) # há NA mas é normal em metadados e não iremos fazer nada

```

Existem NAs, mas em metadados é normal e por isso iremos mantê-los por agora.

Por fim, realizamos a criação de um subset, tal como fizemos com os metadados anteriores, para garantir um dataframe com dados de pacientes presentes em "sample_data_rna", garantindo assim uma análise aos pacientes para os quais possuimos dados relevantes.

```{r Filtração dos dados p}

patient_data_rna = data_patient %>% filter(data_patient$PATIENT_ID %in% sample_data_rna$PATIENT_ID)


```


### data_mutations

Começámos por verificar alguns aspetos relativos ao dataset:

```{r}

class(data_mutations) 

dim(data_mutations)

unlist(lapply(data_mutations,class))

row.names(data_mutations)

row.names(data_mutations) = data_mutations$Hugo_Symbol #Esta linha está a dar erro, cria duplicados

sum(is.na(data_mutations))

```

É possível ver que temos um dataframe com 9910 linhas e 64 colunas. 
No dataframe existem também um número bastante elevados de NAs, 155469.

De seguida, vamos verificar a estrutura interna dos dados de cada coluna:

```{r Preparação dos dados}

str(data_mutations)

colunas_fator <- c(1, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,29,30,31,32, 33, 45, 47, 48, 51, 57, 60, 64)

colunas_numericas <- c(34,35,36,37,43, 54, 58, 63)

colunas_char <- c(2,6,7)

data_mutations[, colunas_fator]<- lapply(data_mutations[, colunas_fator], as.factor)

data_mutations[, colunas_numericas]<- lapply(data_mutations[, colunas_numericas], as.numeric)

data_mutations[, colunas_char]<- lapply(data_mutations[, colunas_char], as.character)

str(data_mutations)

```

Ao analisar a estrutura de dados de cada coluna, percebemos que era necessário transformar alguns dos dados para facilitar a sua manipulação:

- os valores das colunas presentes no vetor associado a "colunas_fator" foram transformadas em fatores;

- os valores das colunas presentes no vetor associado a "colunas_numericas" foram transformados em valores numéricos;

- os valores das colunas presentes no vetor associado a "colunas_char" foram transformados em caracteres. 

Por fim, procedemos à criação de um subset que contém apenas as linhas de "data_mutations" correspondentes às mutações que estão presentes nos dados de "RNA_cpm" para restringir a análise apenas às mutações para as quais temos dados de expressão gênica.

```{r Filtração dos dados m}

mutations_subset = data_mutations %>% filter(data_mutations$Hugo_Symbol %in% RNA_cpm$Hugo_Symbol)

```


# **Sumarização dos dados**


## *data_patient*



```{r Sumarização data_patient}

print(dfSummary(data_patient, style = 'grid', graph.magnif = 1, valid.col = FALSE,
                max.distinct.values = 5, col.widths = c(100, 200, 200, 350, 500, 250),
                dfSummary.silent  = TRUE, headings = FALSE, justify = 'l')
      , method = 'render', max.tbl.height = 500)

```

Considerando variáveis relevantes:

```{r}

colunas_relevantes = c("SEX", "ETHNICITY", "AGE_AT_DIAGNOSIS", "PRIOR_CANCER", "TREATMENT_TYPE", "OS_STATUS", "OS_MONTHS", "CAUSE_OF_DEATH_SOURCE", "DIAGNOSIS")

relev_data_patient <- data_patient[,colunas_relevantes]

boxplot(AGE_AT_DIAGNOSIS ~ OS_STATUS, data = relev_data_patient, main = "Idade do diagnostico vs status", xlab = "Status", ylab = "Idade em anos", col = c("blue", "green", "red"), names = c("NA", "0:LIVING", "1:DECEASED"))

```

O código em cima cria um boxplot que compara as distribuições das idades de diagnóstico entre os diferentes estados de sobrevida. 


Agora pretendemos gerar um gráfico que mostre a distribuição de etnias:

```{r Distibuição de etnias}

valores = table(relev_data_patient$ETHNICITY)

nome = c("AdmixedAsian", "AdmixedBlack", "AdmixedWhite", "Asian", "Black", "HispNative", "White")

pie(valores, labels = rep("", length(valores)), col = c("black",3,4,5,6,7,2), main = "Etinias") 

legend("right", legend = nome, bty = "n", cex = 0.8, fill = c("black",3,4,5,6,7,2))

```

ESCREVER RESULTADOS

De seguida, procedemos à comparação da idade de diagnóstico entre os géneros

```{r Idade de Diagnóstico}

boxplot(AGE_AT_DIAGNOSIS ~ SEX, data = relev_data_patient, main = "Idade do diagnostico vs gênero", xlab = "Gênero", ylab = "Idade em anos", col = c(2,5))

```

ESCREVER RESULTADOS

Acabamos ainda por identificar ainda o diagnóstico mais recorrente.

```{r Diag mais recorrente data_patient}

d = table(relev_data_patient$DIAGNOSIS)

d = as.data.frame(d)

indice_maximo <- which.max(d$Freq)

nome_maximo <- d$Var1[indice_maximo]

nome_maximo

```

## *data_sample*

```{r Sumariazação data_sample}
print(dfSummary(data_sample, style = 'grid', graph.magnif = 1, valid.col = FALSE,
                max.distinct.values = 5, col.widths = c(100, 200, 200, 350, 500, 250),
                dfSummary.silent  = TRUE, headings = FALSE, justify = 'l')
      , method = 'render', max.tbl.height = 500)

```


Depois consideramos variáveis relevantes:

```{r}

colunas_relevantes = c("PATIENT_ID", "GROUP", "SAMPLE_SITE", "PLATFORM", "PB_LYMPHOCYTES_PERCENTAGE", "PB_MONOCYTES_PERCENTAGE")

relev_data_sample <- data_sample[,colunas_relevantes]

pie(table(relev_data_sample$SAMPLE_SITE), main = "Local de recolha das amostras")

```

O gráfico demonstra como as amostras estão distribuídas pelos locais de recolha.

Por último verificamos qual o nome do grupo de diagnóstico mais frequente nos dados

```{r Diag mais recorrente data_sample}

x = table(relev_data_sample$GROUP)

x = as.data.frame(x)

indice_maximo <- which.max(x$Freq)

nome_maximo <- x$Var1[indice_maximo]

nome_maximo

```



## *data_mutations*

```{r Sumarização data_mutations}

print(dfSummary(data_mutations, style = 'grid', graph.magnif = 1, valid.col = FALSE,
                max.distinct.values = 5, col.widths = c(100, 200, 200, 350, 500, 250),
                dfSummary.silent  = TRUE, headings = FALSE, justify = 'l')
      , method = 'render', max.tbl.height = 500)

```


Considerando as variáveis relevantes:

```{r}

colunas_relevantes = c("Chromosome", "Start_Position", "End_Position", "Strand", "Variant_Classification", "Variant_Type", "Tumor_Seq_Allele1", "Tumor_Seq_Allele2", "Validation_Status", "Mutation_Status", "impact", "t_vaf", "tumor_only")

relev_data_mutations = data_mutations[, colunas_relevantes]

barplot(table(relev_data_mutations$Chromosome), main = "Cromossomos", col = "4")

pie(table(relev_data_mutations$Variant_Type), main = "Tipo de variação")

```

Com o código em cima, geramos um gráfico de barras que mostra a contagem de ocorrências de cada cromossoma, e um gráfico de pizza para perceber a distribuição dos tipos de variantes no dataframe.

Depois, verificamos qual a mutação mais comum no Alelo 1 entre as amostras analisadas

```{r Mutação mais comum 1}

mut = table(relev_data_mutations$Tumor_Seq_Allele1)

mut = as.data.frame(mut)

indice_maximo <- which.max(mut$Freq)

nome_maximo <- mut$Var1[indice_maximo]

nome_maximo # A mutação mais comun é a alteração por C

```

ESCREVER SOBRE A MUTAÇÃO MAIS COMUM


Analisamos ainda qual a mutação mais comum no Alelo 2 entre as amostras analisadas:

```{r}

mut2 = table(relev_data_mutations$Tumor_Seq_Allele2)

mut2 = as.data.frame(mut2)

indice_maximo <- which.max(mut2$Freq)

nome_maximo <- mut2$Var1[indice_maximo]

nome_maximo # A mutação mais comum é a alteração por T

```

ESCREVER SOBRE A MUTAÇÃO MAIS COMUM


# **Análise Exploratória**

```{r}
variaveis_patient = c('PATIENT_ID', 'SEX', 'AGE_AT_DIAGNOSIS', 'PRIOR_CANCER', 'TREATMENT_TYPE')

variaveis_sample = c('PATIENT_ID', 'SAMPLE_ID', 'GROUP', 'SAMPLE_SITE')

subset_patient <- patient_data_rna[, variaveis_patient]

subset_sample <- sample_data_rna[, variaveis_sample]

```


# **Análise Univariada**

```{r}

mutation_subset

sample_data_rna

patient_data_rna

```


```{r}

table(patient_data_rna$SEX) #apenas dois grupos
# Testar a variância

variancia_por_sexo <- tapply(patient_data_rna$AGE_AT_DIAGNOSIS, patient_data_rna$SEX, var, na.rm = TRUE)

variancia_por_sexo
# Testar a normalidade

teste_normalidade_masculino=shapiro.test(patient_data_rna$AGE_AT_DIAGNOSIS[patient_data_rna$SEX == "Male"])

teste_normalidade_feminino=shapiro.test(patient_data_rna$AGE_AT_DIAGNOSIS[patient_data_rna$SEX == "Female"])

print(teste_normalidade_masculino)

print(teste_normalidade_feminino)



qqPlot(patient_data_rna$AGE_AT_DIAGNOSIS[patient_data_rna$SEX == "Male"], main = "Q-Q Plot - Masculino")

qqPlot(patient_data_rna$AGE_AT_DIAGNOSIS[patient_data_rna$SEX == "Female"], main = "Q-Q Plot - Feminino")
```

As variâncias são próximas entre os diferentes grupos, e com os gráficos qqPlot e as análisesde normalidade, é possível ver que as distribuições não são normais,  considerando um tamanho elevado das amostras, vamos determiar um t test e analisar relação entre sexo e idade. 

```{r}

t.test(patient_data_rna$AGE_AT_DIAGNOSIS ~ patient_data_rna$SEX, na.rm = TRUE)

```


É possível ver uma diferença nos dados referente aos homens e mulheres.


```{r}

qqPlot(patient_data_rna$AGE_AT_DIAGNOSIS, main = "Q-Q Plot")

idades_sem_na <- na.omit(patient_data_rna$AGE_AT_DIAGNOSIS)

# Criar gráfico de densidade sem valores ausentes
ggdensity(idades_sem_na,
          main = "Gráfico de densidade para a idade dos pacientes",
          xlab = "Idade dos pacientes")

```

## *Análise de varáveis no metadado de mutações*

- "n_vaf" (Frequência do Alelo Variante Normalizado), é uma medida da frequência do alelo variante, normalizada para o número total de leituras, e é comumente usada em análises de variantes genéticas.

- Impact: variável que se refere ao efeito ou consequência que uma determinada mutação pode ter em um gene ou em uma função biológica específica.

```{r Avaliar a distruição variável}
# Avaliar a distribuição variável

sum(is.na(mutations_subset$n_vaf))

ggdensity(mutations_subset$n_vaf)

table(mutations_subset$impact)

qqPlot(mutations_subset$n_vaf) # não é normal

leveneTest(mutations_subset$n_vaf~mutations_subset$impact)

res = kruskal.test(mutations_subset$n_vaf~mutations_subset$impact, data = mutations_subset)

res 
```

Não há diferenças estatisticamente significativas na distribuição da variável n_vaf entre os diferentes níveis de impact. 

## Análise para as variáveis "AGE_AT_PROCUREMENT" e "ELN_2017":

- "AGE_AT_PROCUREMENT" - Idade dos pacientes na aquisição das amostras
- "ELN_2017" - variável usada para classificar pacientes com leucemia mieloide aguda (LMA) em diferentes grupo de risco. 

```{r}
table(data_sample$ELN_2017)

summary(sample_data_rna$AGE_AT_PROCUREMENT)

# Criar o gráfico de dispersão 
ggplot(sample_data_rna, aes(x = ELN_2017, y = AGE_AT_PROCUREMENT, color = ELN_2017)) +
  geom_point(size = 3) +  
  labs(x = "Classificação de Risco ELN 2017", y = "Idade na Aquisição", title = "Idade na Aquisição vs. Classificação de Risco ELN 2017") +  
  theme_minimal() +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


```{r Análise a normalidade e variancias}

qqPlot(sample_data_rna$AGE_AT_PROCUREMENT)

shapiro.test(sample_data_rna$AGE_AT_PROCUREMENT) 

leveneTest(AGE_AT_PROCUREMENT ~ ELN_2017, data = sample_data_rna)

anova_result <- aov(AGE_AT_PROCUREMENT ~ ELN_2017, data = sample_data_rna)

summary(anova_result)

tukey_result <- TukeyHSD(anova_result)

print(tukey_result)
```

Considerando um elevado tamanho da amostra, a análise ANOVA foi feita, mesmo a variável  "AGE_AT_PROCUREMENT" não seguindo a normalida. É possível determinar que a idade dos pacientes interferem na determinação dos diferentes grupos "Favoravel" e "Adverse"
